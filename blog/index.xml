<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blog on luekindykiewicz</title>
    <link>https://lukeindykiewicz.github.com/blog/</link>
    <description>Recent content in Blog on luekindykiewicz</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <lastBuildDate>Thu, 01 Sep 2016 12:22:31 +0200</lastBuildDate>
    <atom:link href="https://lukeindykiewicz.github.com/blog/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>free monads in business application</title>
      <link>https://lukeindykiewicz.github.com/blog/free-monads-in-business-application/</link>
      <pubDate>Thu, 01 Sep 2016 12:22:31 +0200</pubDate>
      
      <guid>https://lukeindykiewicz.github.com/blog/free-monads-in-business-application/</guid>
      <description>

&lt;h1 id=&#34;what&#34;&gt;What&lt;/h1&gt;

&lt;p&gt;This post describes &lt;a href=&#34;https://github.com/lukeindykiewicz/letter-shop-api&#34;&gt;Letter Shop API&lt;/a&gt; implementation which uses Free Monads, exactly Free from &lt;a href=&#34;https://github.com/typelevel/cats&#34;&gt;Cats&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;tl-dr&#34;&gt;tl;dr&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/lukeindykiewicz/letter-shop-free-scala&#34;&gt;show me the code&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;why&#34;&gt;Why&lt;/h1&gt;

&lt;p&gt;There are some nice materials about free monads on the net, but I always wanted to see how such concepts, applied to regular business applications, look like. How difficult or cumbersome it is to implement some business use case using a particular concept, e.g. free monads.&lt;/p&gt;

&lt;p&gt;Letter Shop is my way to make business application implementation comparable. I have explained what it is in this &lt;a href=&#34;http://lukeindykiewicz.com/blog/letter-shop/&#34;&gt;post&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;how&#34;&gt;How&lt;/h1&gt;

&lt;p&gt;Free monads separate algorithm definition from its implementation. We need a program - the code that describes steps of an algorithm, the compiler - the code that interprets/runs some other code for algorithm steps and data on which our algorithm works.&lt;/p&gt;

&lt;h2 id=&#34;adt-as-your-internal-api&#34;&gt;ADT as your internal API&lt;/h2&gt;

&lt;p&gt;We have to define all operations that are possible from business logic point of view as ADT.&lt;/p&gt;

&lt;p&gt;ADT in Scala is described as a trait and case classes/objects implementing it. Each class/object describes one operation. Let&amp;rsquo;s look at &lt;code&gt;GetCart&lt;/code&gt; in &lt;a href=&#34;https://github.com/lukeindykiewicz/letter-shop-free-scala/blob/master/src/main/scala/domain.scala#L27&#34;&gt;StorageADT&lt;/a&gt;:&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-scala&#34; data-lang=&#34;scala&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;GetCart&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cartId&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;extends&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;StorageADT&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;Cart&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;GetCart&lt;/code&gt; case class represents one operation (getting cart of course). It takes one parameter (&lt;code&gt;cartId&lt;/code&gt;) and returns cart, which is represented by &lt;code&gt;StotrageADT&lt;/code&gt; parameterized with &lt;code&gt;Cart&lt;/code&gt; type.&lt;/p&gt;

&lt;p&gt;The whole ADT has a generic parameter which is specified in each class/object implementing it - this parameter is for return type of each operation.&lt;/p&gt;

&lt;p&gt;Defining ADT in the first place looks like some huge amount of code that has to be written just to make free monads work, but in the end it occurs that it makes you think which operations are really needed in your code and it also defines your api. All this operations are your internal api.&lt;/p&gt;

&lt;p&gt;You can of course have different ADTs for different parts of application, like: storage, users, validation, etc.&lt;/p&gt;

&lt;h2 id=&#34;helpers-aka-boilerplate&#34;&gt;Helpers aka boilerplate&lt;/h2&gt;

&lt;p&gt;After defining our plain old ADT we need to lift each class/object from ADT to &lt;code&gt;Free&lt;/code&gt;. In the easiest example it could be done simply by &lt;code&gt;Free.liftF&lt;/code&gt;, but this works when we have only one ADT in our application. I doubt it&amp;rsquo;s true for any business application, so if we don&amp;rsquo;t write small and simple dsl we need to complicate it a little bit.&lt;/p&gt;

&lt;p&gt;There is a special method in &lt;code&gt;Free&lt;/code&gt; called &lt;code&gt;inject&lt;/code&gt;, which in fact calls &lt;code&gt;Free.liftF&lt;/code&gt;. It doesn&amp;rsquo;t lift our ADT, but it lifts value of type, which is injected as defined in a call to &lt;code&gt;Free.inject&lt;/code&gt;. Let&amp;rsquo;s see how does it look in &lt;a href=&#34;https://github.com/lukeindykiewicz/letter-shop-free-scala/blob/master/src/main/scala/free.scala&#34;&gt;code&lt;/a&gt;:&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-scala&#34; data-lang=&#34;scala&#34;&gt;&lt;span&gt;&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;StorageConstructors&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;F&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;_&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]](&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;implicit&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;I&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;Inject&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;StorageADT&lt;/span&gt;, &lt;span class=&#34;kt&#34;&gt;F&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;])&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;getCart&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cartId&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;Free&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;F&lt;/span&gt;, &lt;span class=&#34;kt&#34;&gt;Cart&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;=&lt;/span&gt;
      &lt;span class=&#34;nc&#34;&gt;Free&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;inject&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;StorageADT&lt;/span&gt;, &lt;span class=&#34;kt&#34;&gt;F&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;](&lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;GetCart&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cartId&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;))&lt;/span&gt;
 &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;getCart&lt;/code&gt; is called a smart constructor. This is something that makes our case class &lt;code&gt;GetCart&lt;/code&gt; usable in context of Free when we have more than one ADT. Return type is simply &lt;code&gt;Free&lt;/code&gt; with &lt;code&gt;F&lt;/code&gt; and return type of given operation - &lt;code&gt;Cart&lt;/code&gt; in the above example.&lt;/p&gt;

&lt;p&gt;So coming back to lifting, it &amp;ldquo;repacks&amp;rdquo; (&lt;code&gt;injects&lt;/code&gt;) from &lt;code&gt;StorageADT&lt;/code&gt; type into &lt;code&gt;F&lt;/code&gt; type and the result is lifted into &lt;code&gt;Free&lt;/code&gt;. This &lt;code&gt;F&lt;/code&gt; type in our case is &lt;code&gt;LetterShop&lt;/code&gt;, which is &lt;code&gt;Coproduct&lt;/code&gt; of our ADTs. I will come to &lt;code&gt;Coproduct&lt;/code&gt; in a while.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;StorageConstructors&lt;/code&gt; companion object defines implicit conversion from &lt;code&gt;Inject&lt;/code&gt; to our &lt;code&gt;StorageConstructors&lt;/code&gt;, but at the same time &lt;code&gt;Inject&lt;/code&gt; parameter is automatically created on demand (look into &lt;code&gt;Programs&lt;/code&gt; &lt;a href=&#34;https://github.com/lukeindykiewicz/letter-shop-free-scala/blob/master/src/main/scala/Programs.scala&#34;&gt;trait&lt;/a&gt;, each program needs implicit &lt;code&gt;StorageConstructors&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;We have also defined type alias&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-scala&#34; data-lang=&#34;scala&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;LetterShop&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Coproduct&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;StorageADT&lt;/span&gt;, &lt;span class=&#34;kt&#34;&gt;PriceADT&lt;/span&gt;, &lt;span class=&#34;kt&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;LetterShop&lt;/code&gt; is a &lt;code&gt;Coproduct&lt;/code&gt; of ADTs that we have used in application, that is &lt;code&gt;StorageADT&lt;/code&gt; and &lt;code&gt;PriceADT&lt;/code&gt;. &lt;code&gt;Coproduct&lt;/code&gt; is another type from &lt;code&gt;Cats&lt;/code&gt; which allows us to combine two ADTs and then use it with &lt;code&gt;Free&lt;/code&gt;. If we have more than two ADTs we need to combine one coproduct of two ADTs into another coproduct with third ADT and so on.&lt;/p&gt;

&lt;p&gt;There is a lot of code that has to be written to satisfy the compiler here and it&amp;rsquo;s only preparation for writing programs and compilers - the core part of our application.&lt;/p&gt;

&lt;h2 id=&#34;uc-s-as-programs&#34;&gt;UC&amp;rsquo;s as programs&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Free&lt;/code&gt; is using terms like programs and compilers to talk about code that implements in abstract way the algorithm and code that really executes it. Use case (user story, name it as you wish) is a part of business logic in our code that gathers all the operations needed to achieve some goal. Typically it&amp;rsquo;s equivalent of one request from frontend to our backend code. Let&amp;rsquo;s see how does it look in &lt;a href=&#34;https://github.com/lukeindykiewicz/letter-shop-free-scala/blob/master/src/main/scala/Programs.scala&#34;&gt;code&lt;/a&gt;&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-scala&#34; data-lang=&#34;scala&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;getCartProgram&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cartId&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)(&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;implicit&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;StorageConstructors&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;LetterShop&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;])&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;Free&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;LetterShop&lt;/span&gt;, &lt;span class=&#34;kt&#34;&gt;Cart&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;S._&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;cart&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;getCart&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cartId&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
  &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;yield&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cart&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;getCartProgram&lt;/code&gt; takes all needed params in the first parameter list (&lt;code&gt;cartId&lt;/code&gt; in our case) and implicit &lt;code&gt;StorageConstructors[LetterShop]&lt;/code&gt;. Compiler sees the need for &lt;code&gt;StorageConstructors&lt;/code&gt; and finds implicit conversion in &lt;code&gt;StorageConstructors&lt;/code&gt; companion object, which in turn needs &lt;code&gt;Inject&lt;/code&gt; type. We don&amp;rsquo;t have such value in our code, but &lt;code&gt;cats.free.Inject.leftInjectInstance&lt;/code&gt; can be found. That&amp;rsquo;s why everything compiles and all the types are in place.&lt;/p&gt;

&lt;p&gt;All steps of the program are coded using for comprehension. Return type for each program is also &lt;code&gt;Free&lt;/code&gt;. That makes it perfect for composition, because all our business logic returns &lt;code&gt;Free&lt;/code&gt;. Let&amp;rsquo;s look at &lt;code&gt;checkoutCartProgram&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-scala&#34; data-lang=&#34;scala&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;checkoutCartProgram&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cartId&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;promoCode&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;Option&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;])(&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;implicit&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;StorageConstructors&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;LetterShop&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;],&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;PromoConstructors&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;LetterShop&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;])&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;Free&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;LetterShop&lt;/span&gt;, &lt;span class=&#34;kt&#34;&gt;Checkout&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;S._&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;_&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;val&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;uuid&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;UUID&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;randomUUID&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;toString&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;checkCartProgram&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cartId&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;promoCode&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;cart&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;getCart&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cartId&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;_&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;addToReceipts&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cartId&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;ReceiptHistory&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;price&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;uuid&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cart&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;letters&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;))&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;_&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;removeCart&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cartId&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
  &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;yield&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Checkout&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;price&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;uuid&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This UC/program has more steps and as we can see first step just calls other program. That is followed by some other steps. Of course such composition is also possible without using &lt;code&gt;Free&lt;/code&gt;, but having one type container for every UC makes it a lot easier.&lt;/p&gt;

&lt;p&gt;Program only generates steps of the algorithm. When it comes to the execution &amp;hellip; we need another code - compiler.&lt;/p&gt;

&lt;h2 id=&#34;compilers&#34;&gt;Compilers&lt;/h2&gt;

&lt;p&gt;We always wanted to write applications in which parts of them can be changed to some other parts without fixing the whole application. There are many ways to do this (interfaces, ports and adapters architecture, etc.). Free monads give us one more option. It&amp;rsquo;s nice because it&amp;rsquo;s really interchangeable without bothering that our business logic will fail (at least from business logic &amp;ldquo;algorithm&amp;rdquo; point of view).&lt;/p&gt;

&lt;p&gt;So let&amp;rsquo;s write a compiler. In case of free monads from &lt;code&gt;Cats&lt;/code&gt; compiler is a &lt;code&gt;cats.arrow.NaturalTransformation&lt;/code&gt; (aliased as &lt;code&gt;~&amp;gt;&lt;/code&gt;) from ADT, that we have created, to some other type. It could be &lt;code&gt;Future&lt;/code&gt;, but the simplest one is &lt;code&gt;Id&lt;/code&gt;. Compiler has to be written for defined ADTs.&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-scala&#34; data-lang=&#34;scala&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;storageCompiler&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;StorageADT&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;~&amp;gt;&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;Id&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;StorageADT&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;~&amp;gt;&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Id&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt; 
  &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;apply&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;](&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fa&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;StorageADT&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;])&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;Id&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fa&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;match&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;GetCart&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cartId&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Cart&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;carts&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;getOrElse&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cartId&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;))&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;AddToCart&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cartId&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;letters&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;=&amp;gt;&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;carts&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cartId&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;letters&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
      &lt;span class=&#34;o&#34;&gt;()&lt;/span&gt;
  &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;
  &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The whole code is &lt;a href=&#34;https://github.com/lukeindykiewicz/letter-shop-free-scala/blob/master/src/main/scala/Compilers.scala&#34;&gt;here&lt;/a&gt;. This example is using &lt;code&gt;TrieMap&lt;/code&gt; and stores everything in memory just for simplicity. It could also go to database or connect to some service - that depends on compiler implementation.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;storageCompiler&lt;/code&gt; is a compiler for &lt;code&gt;StorageADT&lt;/code&gt; and it defines natural transformation from &lt;code&gt;StorageADT&lt;/code&gt; to &lt;code&gt;Id&lt;/code&gt;. To make it work we have to implement apply method which should know what to do with every element of our ADT. That&amp;rsquo;s why we use simple pattern matching. Of course compiler will tell us if we forget to implement one of case classes/objects as they are under sealed trait.&lt;/p&gt;

&lt;p&gt;The other compiler from our example, &lt;code&gt;priceCompiler&lt;/code&gt;, delegates execution to &lt;code&gt;PromotionService&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The last step is to combine two compilers to be able to run all our programs - it&amp;rsquo;s simple:&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-scala&#34; data-lang=&#34;scala&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;compiler&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;LetterShop&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;~&amp;gt;&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;Id&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;storageCompiler&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;or&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;priceCompiler&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;I use this compiler in &lt;a href=&#34;https://github.com/lukeindykiewicz/letter-shop-free-scala/blob/master/src/main/scala/main.scala#L36&#34;&gt;Routes&lt;/a&gt; to be able to run programs.&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-scala&#34; data-lang=&#34;scala&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;lazy&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;val&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;getCart&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;get&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;Segment&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cartId&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;=&amp;gt;&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;complete&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;getCartProgram&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cartId&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;).&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;foldMap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cmp&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;))&lt;/span&gt;
  &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;To run the program we need to call the program with needed params and &lt;code&gt;foldMap&lt;/code&gt; it with chosen compiler.&lt;/p&gt;

&lt;h1 id=&#34;materials&#34;&gt;Materials&lt;/h1&gt;

&lt;p&gt;The best material on practical usage of Free Monads in my opinion is &lt;a href=&#34;http://typelevel.org/cats/tut/freemonad.html&#34;&gt;Free&lt;/a&gt; description from Typelevel&lt;/p&gt;

&lt;h1 id=&#34;summary&#34;&gt;Summary&lt;/h1&gt;

&lt;p&gt;This blog post describes how to use &lt;code&gt;Free&lt;/code&gt; from &lt;code&gt;Cats&lt;/code&gt; to implement exemplary business application. Of course it&amp;rsquo;s not a silver bullet to take and use in every application, but it looks interesting. Especially when flexibility in choosing the way our code is executed is needed. It also gives our code some structure with one main type to which business logic is implemented. It&amp;rsquo;s useful in many ways not to have a code in which every UC returns different type (i.e. Option, Future, Either, etc.). For sure a lot of additional code has to be written to achieve this. The decision is yours.&lt;/p&gt;

&lt;h1 id=&#34;comments&#34;&gt;Comments&lt;/h1&gt;

&lt;p&gt;If you have some opinions about &lt;code&gt;Free&lt;/code&gt; and/or this text feel free to make PR, create issues and comment on twitter.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>letter shop</title>
      <link>https://lukeindykiewicz.github.com/blog/letter-shop/</link>
      <pubDate>Wed, 24 Aug 2016 18:30:50 +0200</pubDate>
      
      <guid>https://lukeindykiewicz.github.com/blog/letter-shop/</guid>
      <description>

&lt;h1 id=&#34;what&#34;&gt;What&lt;/h1&gt;

&lt;p&gt;This post describes a made up application - Letter Shop, why I created it and how it was done.&lt;/p&gt;

&lt;h1 id=&#34;tl-dr&#34;&gt;tl;dr&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/lukeindykiewicz/letter-sh&#34;&gt;TCK code&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/lukeindykiewicz/letter-shop-api&#34;&gt;API code&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;why&#34;&gt;Why&lt;/h1&gt;

&lt;p&gt;Letter Shop is an attempt to make comparison of concepts possible, of course in a very practical way. I wanted to have some api/tests/problem that I can implement with different approaches (like using monads, using event sourcing, etc.). Each approach is best in a particular situation and simple examples, &amp;ldquo;hello worlds&amp;rdquo; show exactly those cases. Then it comes to a real world example and sometimes it&amp;rsquo;s not so sweet. There is &lt;a href=&#34;http://todomvc.com/&#34;&gt;TodoMVC&lt;/a&gt; and &lt;a href=&#34;http://www.todobackend.com/&#34;&gt;Todo-Backend&lt;/a&gt;, but I wanted to have more control over the problem, to make it evolve according to the concepts I&amp;rsquo;m exploring.
There is also another reason, I want to have this api/tck as my kata for further exploring of programming concepts and languages.&lt;/p&gt;

&lt;p&gt;There are two main parts of Letter Shop:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;API - this is yaml (swagger) description of endpoints available in the Letter Shop&lt;/li&gt;
&lt;li&gt;TCK - tests for all main features, green means a proper implementation of an API&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;how&#34;&gt;How&lt;/h1&gt;

&lt;h2 id=&#34;idea&#34;&gt;Idea&lt;/h2&gt;

&lt;p&gt;I wanted to model something that is a little bit more complicated than todo, but also is easy enough to not loose interest in building it and be able to quickly explain what it does. The main goal is to train/check new programming ideas, not explore business domain. So I took a shop case, as it is a well know situation for everyone. We have cart, things we want to buy and some price. I didn&amp;rsquo;t want to implement a lot of different products in the shop, so I decided that the shop sell letters, like: a,b,c. Sounds stupid, but for this purpose suits very good.&lt;/p&gt;

&lt;h2 id=&#34;api&#34;&gt;API&lt;/h2&gt;

&lt;p&gt;Api (&lt;a href=&#34;http://lukeindykiewicz.com/letter-shop-api/#/default&#34;&gt;swagger ui&lt;/a&gt;) contains just few endpoints - basic features of Letter Shop. We can:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;add letters to the cart&lt;/li&gt;
&lt;li&gt;replace existing cart with new letters (also clean cart)&lt;/li&gt;
&lt;li&gt;get cart info&lt;/li&gt;
&lt;li&gt;check cart (just checks the price of current cart)&lt;/li&gt;
&lt;li&gt;checkout cart (price, receipt id and cleans cart)&lt;/li&gt;
&lt;li&gt;set price for given letter (default price is 10)&lt;/li&gt;
&lt;li&gt;get all receipts from the system&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Yes, everything is public, no user/admin login. It has to be simple.&lt;/p&gt;

&lt;p&gt;This is pure CRU (create, read, update) stuff, so I decided to add some price logic. So, as in every shop, there are promotions:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Three for two (only for letter &amp;lsquo;a&amp;rsquo; and &amp;lsquo;X&amp;rsquo;) - when you buy three letters you pay only for two&lt;/li&gt;
&lt;li&gt;Promo code to get 10 percent discount&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Read &lt;a href=&#34;https://github.com/lukeindykiewicz/letter-shop-tck/blob/master/src/test/scala/lettershop/CheckCartPriceTest.scala&#34;&gt;CheckCartPriceTest&lt;/a&gt; to check promotion rules exactly.&lt;/p&gt;

&lt;h2 id=&#34;tck&#34;&gt;TCK&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/lukeindykiewicz/letter-shop-tck/tree/master/src/test/scala/lettershop&#34;&gt;Tests&lt;/a&gt; are written in Scala and specs2. They describe high level functionalities for Letter Shop.&lt;/p&gt;

&lt;h1 id=&#34;what-is-missing&#34;&gt;What is missing&lt;/h1&gt;

&lt;p&gt;I decided to put Letter Shop online, although I don&amp;rsquo;t know what should be there to make it 1.0 ready. As I mentioned earlier this will probably evolve. On the other hand I think it is enough to start implementing Letter Shop. Things that are planned:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;add validation, as this is always a case in business applications&lt;/li&gt;
&lt;li&gt;think of a way to run tests in some CI (tck is a separate project).&lt;/li&gt;
&lt;li&gt;write free monads implementation&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;implementations&#34;&gt;Implementations&lt;/h1&gt;

&lt;p&gt;Very simple implementation is already there, just to test the tests. &lt;a href=&#34;https://github.com/lukeindykiewicz/letter-shop-classic-scala&#34;&gt;Check it&lt;/a&gt; if you want.&lt;/p&gt;

&lt;h1 id=&#34;summary&#34;&gt;Summary&lt;/h1&gt;

&lt;p&gt;This is a first blog about Letter Shop, the definition that is going to be implemented and descibed in future blog posts.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>sbt search maven plugin</title>
      <link>https://lukeindykiewicz.github.com/blog/sbt-search-maven-plugin/</link>
      <pubDate>Tue, 26 Jan 2016 18:27:31 +0100</pubDate>
      
      <guid>https://lukeindykiewicz.github.com/blog/sbt-search-maven-plugin/</guid>
      <description>

&lt;h1 id=&#34;what&#34;&gt;What&lt;/h1&gt;

&lt;p&gt;This is a blog post about sbt plugin to query search.maven.org&lt;/p&gt;

&lt;h1 id=&#34;tl-dr&#34;&gt;tl;dr&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/blstream/sbt-search-maven-plugin&#34;&gt;show me the code&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;why&#34;&gt;Why&lt;/h1&gt;

&lt;p&gt;Most development tasks can be done without leaving your favorite editor/ide nor console.
Writing Scala code is no different: sbt gives you a lot of power to run code and tests, to package and publish application.&lt;/p&gt;

&lt;p&gt;There is one small thing though, forcing you to leave that environment and go to a browser - to find the exact name of dependency for your project.
Unless you have super memo powers you will probably have to check the group id for akka, or latest version for any other package that you would like to include in your project.&lt;/p&gt;

&lt;p&gt;To make it even simpler, I created &lt;em&gt;sbt-search-maven-plugin&lt;/em&gt;. Just type &lt;code&gt;searchMaven something&lt;/code&gt; and everything is clear. This prints the same results as &lt;code&gt;search.maven.org&lt;/code&gt; without leaving sbt.&lt;/p&gt;

&lt;h1 id=&#34;plugin-development&#34;&gt;Plugin development&lt;/h1&gt;

&lt;p&gt;In order to make this happen I had to get some knowledge on how to write a sbt plugin. There are three great sources you can check:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://mukis.de/pages/sbt-autoplugins-tutorial/&#34;&gt;SBT AutoPlugins Tutorial&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://eed3si9n.com/testing-sbt-plugins&#34;&gt;testing sbt plugins&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.scala-sbt.org/0.13/docs/Plugins.html&#34;&gt;Plugins in sbt documentation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;These are all great, but I wanted to create plugin that gets some user input from sbt shell, which is not covered in these references.&lt;/p&gt;

&lt;h1 id=&#34;input-plugin&#34;&gt;Input plugin&lt;/h1&gt;

&lt;p&gt;Plugin code is similar as in above examples, but main &amp;ldquo;entry&amp;rdquo; point for your code is different, as we need InputKey.
There are some important places to look at:&lt;/p&gt;

&lt;h2 id=&#34;build-sbt&#34;&gt;build.sbt&lt;/h2&gt;

&lt;p&gt;The most important part for developing a plugin is&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-scala&#34; data-lang=&#34;scala&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sbtPlugin&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The whole &lt;a href=&#34;https://github.com/blstream/sbt-search-maven-plugin/blob/master/build.sbt&#34;&gt;build.sbt&lt;/a&gt; for this plugin.&lt;/p&gt;

&lt;h2 id=&#34;extends-autoplugin&#34;&gt;extends AutoPlugin&lt;/h2&gt;

&lt;p&gt;The entry point for your code should be placed in an object that extends &lt;code&gt;sbt.AutoPlugin&lt;/code&gt;. This in turn should have another object defined: &lt;code&gt;autoImport&lt;/code&gt; with definition of task.&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-scala&#34; data-lang=&#34;scala&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;object&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;autoImport&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;lazy&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;val&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;searchMaven&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;InputKey&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;Unit&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;](&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;quot;searchMaven&amp;quot;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;quot;Search maven&amp;quot;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Input key makes it possible to get input provided by user from sbt shell. To write some implementation we need one more thing:&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-scala&#34; data-lang=&#34;scala&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;override&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;lazy&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;val&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;projectSettings&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Seq&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;searchMaven&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;search&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;complete&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;DefaultParsers&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;spaceDelimited&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;quot;&amp;lt;arg&amp;gt;&amp;quot;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;).&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;parsed&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;streams&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;log&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;search&lt;/code&gt; from snippet above is a regular Scala function in which we can finally implement our new feature.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sbt.Keys._&lt;/code&gt; contain a lot of useful things that we can use in our code, like &lt;code&gt;scalaVersion&lt;/code&gt; defined in one&amp;rsquo;s project or &lt;code&gt;streams.value.log&lt;/code&gt;, which we use in our plugin to print results to user.&lt;/p&gt;

&lt;p&gt;The whole file can be found &lt;a href=&#34;https://github.com/blstream/sbt-search-maven-plugin/blob/master/src/main/scala/com/blstream/sbtsearchmavenplugin/SbtSearchMavenPlugin.scala&#34;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;additional-sbt-settings&#34;&gt;Additional sbt settings&lt;/h1&gt;

&lt;p&gt;There are two things that should be mentioned here.&lt;/p&gt;

&lt;p&gt;To make your plugin be enabled by default you should add such override:
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-scala&#34; data-lang=&#34;scala&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;override&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;trigger&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;allRequirements&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

This simply says that this plugin will be activated when all required plugins are present. Plugins, that this plugin depends on, could be defined by overriding def &lt;code&gt;requires&lt;/code&gt; (it&amp;rsquo;s empty by default)&lt;/p&gt;

&lt;p&gt;This plugin doesn&amp;rsquo;t interact with code in project - it just searches for artifacts - so we don&amp;rsquo;t want our code to be run multiple times when it&amp;rsquo;s executed inside multimodule project.
To avoid this, the additional setting has to be specified:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-scala&#34; data-lang=&#34;scala&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;aggregate&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;searchMaven&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

This stops the task from running in submodules.&lt;/p&gt;

&lt;h2 id=&#34;for-testing&#34;&gt;for testing&lt;/h2&gt;

&lt;p&gt;If you use version without &lt;code&gt;SNAPSHOT&lt;/code&gt; suffix and you don&amp;rsquo;t want to get warnings about deprecation during packaging your plugin, just add  &lt;code&gt;isSnapshot := true&lt;/code&gt;  to your &lt;code&gt;build.sbt&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&#34;testing-sbt-plugin&#34;&gt;Testing sbt plugin&lt;/h1&gt;

&lt;h2 id=&#34;unit-tests&#34;&gt;unit tests&lt;/h2&gt;

&lt;p&gt;Nothing fancy here, just simple unit test for code that&amp;rsquo;s not related to sbt.&lt;/p&gt;

&lt;h2 id=&#34;scripted&#34;&gt;scripted&lt;/h2&gt;

&lt;p&gt;Scripted is the default mechanism for testing sbt plugins by writing scripts for sbt. Search maven is not building anything,
so we can just prepare basic script to check whether &lt;code&gt;searchMaven&lt;/code&gt; command is available and executable with a success.&lt;/p&gt;

&lt;p&gt;A special directory structure has to be used. Tests are placed in &lt;code&gt;sbt-test&lt;/code&gt; in &lt;code&gt;src&lt;/code&gt;. Under that directory another two directories have to be created for test group and test itself. The full path looks like this:&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-scala&#34; data-lang=&#34;scala&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;projectHome&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;src&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sbt&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;test&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;testGroup&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;/&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;testName&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;In such a path test should be described as:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;plugins.sbt&lt;/code&gt; inside of the project dir that adds plugin to the test project&lt;/li&gt;
&lt;li&gt;&lt;code&gt;test&lt;/code&gt; file that contains script (test scenario)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;build.sbt&lt;/code&gt; file that describes the test build and an assertions for test. Assertions are written in form of the sbt tasks.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Compare the &lt;a href=&#34;https://github.com/blstream/sbt-search-maven-plugin/tree/master/src/sbt-test/test-group/usage-help-test&#34;&gt;usage-help-test&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;make-it-available-for-everyone&#34;&gt;Make it available for everyone&lt;/h1&gt;

&lt;p&gt;The best description can be found &lt;a href=&#34;http://www.scala-sbt.org/0.13/docs/Bintray-For-Plugins.html&#34;&gt;here&lt;/a&gt;. The screenshots are a bit outdated, but most of the content is still valid.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/blstream/sbt-search-maven-plugin/blob/master/build.sbt&#34;&gt;build.sbt&lt;/a&gt; can stay simple.&lt;/p&gt;

&lt;h1 id=&#34;contribution&#34;&gt;Contribution&lt;/h1&gt;

&lt;p&gt;You can pick a feature from the future work section in &lt;a href=&#34;https://github.com/blstream/sbt-search-maven-plugin&#34;&gt;readme&lt;/a&gt;,
implement issue with feature proposal (if any) or fix some bugs. Pull requests are very welcome!&lt;/p&gt;

&lt;h1 id=&#34;summary&#34;&gt;Summary&lt;/h1&gt;

&lt;p&gt;This blog describes how to write a simple sbt plugin, test it and publish it.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>